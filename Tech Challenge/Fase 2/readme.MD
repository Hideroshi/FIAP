# Tech Challenge - P√≥s-Tech SOAT - FIAP
# Fase 2

Alunos:

* Andr√© Mattos - RM358905
* Aurelio Thomasi Jr - RM358104
* Leonardo Ramires - RM358190
* Lucas Arruda - RM358628
* Pedro Marins - RM356883

## Interface TKInter 

* Aurelio Thomasi Jr - RM358104

## Evid√™ncias do projeto
- [Link para o v√≠deo do projeto](https://youtu.be/LQtUcsGbxds)

## Como rodar o projeto

1. Clonar o reposit√≥rio
   ```bash
   git clone https://github.com/Hideroshi/FIAP.git
   ```
2. Instalar as depend√™ncias
   ```bash
   pip install -r Fase2/requirements.txt
   ```
3. Rodar o projeto
   ```bash
   python Fase2/main_tkinter.py
   ```

> **Sobre instala√ß√£o das depend√™ncias**: √â recomend√°vel utilizar o ambiente virtual do Python para instalar as depend√™ncias, utilizando o comando `python -m venv .venv` e depois ativar o ambiente virtual com o comando `source .venv/bin/activate`.

## Defini√ß√£o do Problema
O problema consiste em alocar ordens de servi√ßo (OS) de manuten√ß√£o para operadores de forma otimizada, considerando as habilidades necess√°rias para cada ordem e as habilidades dos operadores dispon√≠veis. 
O problema a ser resolvido √© maximizar a produtividade operacional, assegurando o cumprimento dos prazos estabelecidos, evitar horas extras desnecess√°rias e garantir que as ordens sejam atendidas dentro do prazo estipulado.

## Objetivos
O projeto aborda o desafio cr√≠tico de otimiza√ß√£o na aloca√ß√£o de ordens de servi√ßo (OS) de manuten√ß√£o. Atrav√©s de um algoritmo especializado, o sistema realiza o pareamento preciso entre as compet√™ncias t√©cnicas dos operadores e as exig√™ncias espec√≠ficas de cada ordem.

Alocar ordens de servi√ßo de forma eficiente, maximizando a compatibilidade entre as habilidades dos operadores e as habilidades necess√°rias para as ordens.
Minimizar o n√∫mero de horas extras trabalhadas pelos operadores.
Garantir que as ordens de maior prioridade sejam atendidas dentro do prazo.

## O Projeto
![Fluxograma do Algoritmo Gen√©tico](assets/fluxograma.jpeg)

*Figura 1: Fluxograma do Algoritmo Gen√©tico*

Este projeto foi desenvolvido utilizando um algoritmo gen√©tico para otimizar a aloca√ß√£o de ordens de servi√ßo aos operadores. As seguintes informa√ß√µes relevantes sobre as ordens e operadores s√£o utilizadas para a otimiza√ß√£o:

- **Dados das ordens**: Incluem o tempo estimado de execu√ß√£o, habilidades necess√°rias, prioridade, status, e o dia esperado de in√≠cio do atendimento.
- **Dados dos operadores**: Cont√™m as habilidades dispon√≠veis, n√≠vel de qualifica√ß√£o e horas dispon√≠veis.

Abaixo est√£o os pontos essenciais desta solu√ß√£o, com os principais detalhes:

### 1. Reajuste nas Fun√ß√µes de Aptid√£o
- ‚ú® Adi√ß√£o de pesos considerando a prioridade da OS
- üìä Penaliza√ß√£o proporcional por horas extras

### 2. Otimiza√ß√£o do Crossover
- üîÑ Crossover em dois segmentos com ponto de corte aleat√≥rio
- üìä Valida√ß√£o de compatibilidade de habilidades (m√≠nimo 50%)
- üîí Garantia de atribui√ß√£o √∫nica para cada ordem
- üéØ Realoca√ß√£o aleat√≥ria de ordens n√£o atribu√≠das

### 3. Processo de Muta√ß√£o Inteligente
- üß¨ Taxa de muta√ß√£o adaptativa (reduz ao longo das gera√ß√µes)
- üéØ Valida√ß√£o de compatibilidade de habilidades do operador
- üîÑ Verifica√ß√£o da qualidade p√≥s-muta√ß√£o
- ‚Ü©Ô∏è Revers√£o autom√°tica de muta√ß√µes prejudiciais

### 4. Sistema de Elitismo
- üèÜ Preserva√ß√£o dos N melhores indiv√≠duos (5 melhores por default)
- üìà Manuten√ß√£o de solu√ß√µes de alta qualidade entre gera√ß√µes

> **Sobre o elitismo**: Os 5 melhores indiv√≠duos s√£o preservados entre as gera√ß√µes. Se o elitismo for alterada para 7, os 7 melhores indiv√≠duos seriam preservados.

### 5. Gest√£o Populacional
- üîÑ Reinicializa√ß√£o parcial peri√≥dica (metade da popula√ß√£o)
- üéØ Preven√ß√£o de converg√™ncia prematura para uma solu√ß√£o sub√≥tima

### 6. Controle de Qualifica√ß√£o
- ‚úÖ Exig√™ncia m√≠nima de 50% das habilidades necess√°rias
- üö´ Preven√ß√£o de aloca√ß√µes inadequadas

## Detalhamento do Algoritmo Gen√©tico

### 1. Gera√ß√£o da Popula√ß√£o Inicial üå±
A popula√ß√£o inicial consiste em um conjunto de solu√ß√µes (indiv√≠duos) geradas aleatoriamente, onde cada solu√ß√£o representa uma poss√≠vel aloca√ß√£o de ordens de servi√ßo ao longo do per√≠odo de 5 dias.
Tamb√©m existe uma op√ß√£o de gerar a popula√ß√£o inicial com base em uma solu√ß√£o pr√©-definida.

#### Processo de Gera√ß√£o:
- **Inicializa√ß√£o**: Estrutura base `{"orders": {order_id: {"day": None, "operator": None, "status": "n√£o atendida"}}, "fitness": 0}`
- **Valida√ß√£o de Habilidades**: Filtra operadores v√°lidos com habilidades m√≠nimas necess√°rias
- **Distribui√ß√£o Aleat√≥ria**: Para cada ordem:
  - Atribui dia aleat√≥rio (1 a N dias)
  - Seleciona operador compat√≠vel aleatoriamente
  - Define status baseado no prazo esperado (stats poss√≠veis: "n√£o atendida", "atendida", "atrasada")

### 2. Processo de Sele√ß√£o üéØ
Utilizamos um processo de sele√ß√£o adaptativo para selecionar os pais para a pr√≥xima gera√ß√£o.
Esse processo √© feito atrav√©s dos seguintes passos:

### 3. Processo de Crossover üîÑ
O Crossover √© feito atrav√©s de dois segmentos, com as seguintes caracter√≠sticas:

#### Metodologia do Crossover:
1. **Inicializa√ß√£o**:
   - Cria filho vazio: `{"orders": {}, "fitness": 0}`
   - Garante unicidade das ordens a serem distribuidas (Utiliza√ß√£o da estrutura de dados set para garantir a unicidade)

2. **Sele√ß√£o do Ponto**:
   - Escolha aleat√≥ria do ponto de divis√£o na lista de ordens
   - `crossover_point = random.randint(1, len(orders_parent1) - 1)`

3. **Primeiro Segmento**:
   - Copia ordens do pai 1 at√© o ponto de crossover
   - Adiciona apenas se ordem n√£o foi atribu√≠da anteriormente

4. **Segundo Segmento**:
   - Copia ordens do pai 2 ap√≥s o ponto de crossover
   - Evita duplica√ß√£o de ordens

5. **Tratamento de Ordens N√£o Atribu√≠das**:
   - Identifica ordens que n√£o foram atribu√≠das
   - Atribui aleatoriamente a operadores compat√≠veis
   - Define dia e status baseado no prazo esperado (stats poss√≠veis: "n√£o atendida", "atendida", "atrasada")

### 4. Processo de Muta√ß√£o üß¨
A muta√ß√£o introduz varia√ß√µes nas solu√ß√µes que s√£o feitas para manter a diversidade gen√©tica e evitar a converg√™ncia prematura para uma solu√ß√£o sub√≥tima. Como foi descrito no fluxograma, a muta√ß√£o √© feita atrav√©s dos seguintes passos:

#### Procedimento:
1. **Taxa de Muta√ß√£o Adaptativa**:
   - Cada solu√ß√£o tem chance de `_MUTATION_RATE` de sofrer muta√ß√£o
   - Altera√ß√µes podem incluir novo dia ou operador para ordens selecionadas

2. **Reinicializa√ß√£o Peri√≥dica**:
   - A cada 10 gera√ß√µes (valor default)
   - Novas solu√ß√µes s√£o geradas aleatoriamente para metade da popula√ß√£o com o menor fitness.
   - Fitness √© recalculado para novos indiv√≠duos

3. **Valida√ß√µes**:
   - Verifica compatibilidade de habilidades do novo operador
   - Atualiza status (atendida/atrasada) baseado no novo dia
   - Recalcula o fitness ap√≥s muta√ß√£o

4. **Preserva√ß√£o de Elite**:
- Os 5 melhores indiv√≠duos s√£o preservados (5 √© um valor default)
- Garante que boas solu√ß√µes n√£o sejam perdidas

5. **Controle de Qualidade**:
   - Compara fitness antes e depois da muta√ß√£o
   - Reverte mudan√ßas se o fitness piorar, para evitar a converg√™ncia prematura para uma solu√ß√£o sub√≥tima

### 5. Fun√ß√£o de Aptid√£o ‚öñÔ∏è
A fun√ß√£o Fitness avalia a qualidade das solu√ß√µes considerando m√∫ltiplos crit√©rios.
Os crit√©rios de avalia√ß√£o s√£o os seguintes:

#### Crit√©rios de Avalia√ß√£o:
1. **Compatibilidade de Habilidades**:
   - Verifica√ß√£o se operador possui as habilidades necess√°rias para a ordem
   - Pontua√ß√£o positiva para matches completos
   - Penalidades para incompatibilidades

2. **Gest√£o de Prazos e Status**:
   - Verifica√ß√£o do in√≠cio esperado vs. dia alocado
   - Status atualizado como "atendida" ou "atrasada" baseado no prazo
   - Prioriza√ß√£o de ordens urgentes e alta prioridade

3. **Controle de Capacidade**:
   - Monitoramento de horas por operador por dia
   - Respeito √†s horas dispon√≠veis por turno (evitar horas extras)
   - Distribui√ß√£o balanceada entre operadores

4. **Otimiza√ß√£o Evolutiva e par√¢metros configur√°veis do algoritmo**:
   - N√∫mero de dias organizados pela execu√ß√£o do algoritmo (configur√°vel via `_DAYS`)
   - N√∫mero de operadores dispon√≠veis (configur√°vel via `_N_OPERATORS`)
   - N√∫mero de ordens de servi√ßo a serem alocadas (configur√°vel via `_N_ORDERS`)
   - Popula√ß√£o inicial de 50 indiv√≠duos (configur√°vel via `_POPULATION_SIZE`)
   - Execu√ß√£o por 50 gera√ß√µes (configur√°vel via `_GENERATIONS`)
   - Taxa de muta√ß√£o de 30% (configur√°vel via `_MUTATION_RATE`)
   - Elitismo preservando os 5 melhores indiv√≠duos (configur√°vel via `_ELITISM_SIZE`)
   - Reinicializa√ß√£o de 50% da popula√ß√£o a cada 10 gera√ß√µes (configur√°vel via `_REINITIALIZE_INTERVAL`)

5. **Finaliza√ß√£o dos algoritmos**:
   - Sele√ß√£o da melhor solu√ß√£o
   - C√°lculo das m√©tricas finais:
     - Total de ordens alocadas e n√£o alocadas
     - Distribui√ß√£o por prioridade
     - Distribui√ß√£o por dia
     - Horas extras por operador
   - Gera√ß√£o de relat√≥rios comparativos (incluindo valor de fitness):
     - Algoritmo Gen√©tico
     - Aloca√ß√£o Humana
     - Algoritmo Guloso
     - Programacao Linear
   - Convers√£o para DataFrame com detalhes de:
     - Aloca√ß√£o ordem-operador
     - Compatibilidade de habilidades
     - Status de atendimento
     - Controle de horas extras
   - Visualiza√ß√£o interativa com PyGame do calend√°rio de aloca√ß√µes

### 6. Relat√≥rio com PyGame üéÆ
![Relat√≥rio com PyGame](assets/relatorio.gif)

*Figura 2: Relat√≥rio com PyGame*

Este relat√≥rio foi gerado utilizando a biblioteca PyGame, que √© uma biblioteca Python para cria√ß√£o de jogos e simula√ß√µes. O relat√≥rio √© respons√°vel por exibir o resultado do algoritmo gen√©tico de forma visual, mostrando a aloca√ß√£o das ordens de servi√ßo aos operadores ao longo do per√≠odo de 5 dias, em formato de um calend√°rio.

---

## **Atualiza√ß√£o da Interface**
### **1. Relat√≥rio com Tkinter e TTKBootstrap**

A interface foi desenvolvida utilizando as bibliotecas **Tkinter** e **TTKBootstrap**, proporcionando uma experi√™ncia interativa e din√¢mica para o usu√°rio. Durante a execu√ß√£o do algoritmo, o **medidor de melhor fitness** √© atualizado em tempo real, permitindo que o usu√°rio acompanhe o progresso do c√°lculo de forma visual.

Al√©m disso, a interface permite a intera√ß√£o direta com as tabelas de **ordens** e **operadores**, facilitando a visualiza√ß√£o e o gerenciamento dos dados durante a execu√ß√£o do algoritmo.


![Interface TTKinter](assets/tkinterface.png)

*Figura 3: Interface gr√°fica desenvolvida com Tkinter e TTKBootstrap.*

### **2. Funcionalidades de Exporta√ß√£o e Intera√ß√£o**
A interface agora inclui funcionalidades avan√ßadas para **exporta√ß√£o de resultados**. Os dados podem ser salvos nos formatos **CSV** e **Excel**, proporcionando flexibilidade para an√°lise posterior ou compartilhamento.

A tabela de resultados √© totalmente interativa, permitindo que o usu√°rio explore os dados de forma intuitiva. Embora existam alguns **bugs conhecidos** relacionados √† ferramenta de interface, eles n√£o comprometem o funcionamento geral ou a precis√£o dos resultados.

![Interface TTKinter](assets/tkinterface_results.png)

*Figura 4: Tabela de resultados interativa com op√ß√µes de exporta√ß√£o.*

---

### **Melhorias Futuras**

- **Corre√ß√£o de Bugs**: Estamos trabalhando para resolver os pequenos bugs relacionados √† interface, visando uma experi√™ncia ainda mais fluida.
- **Novas Funcionalidades**: Planejamos adicionar mais op√ß√µes de personaliza√ß√£o e relat√≥rios detalhados para atender √†s necessidades dos usu√°rios.

---

Este projeto est√° em constante evolu√ß√£o, e sua contribui√ß√£o √© bem-vinda! Sinta-se √† vontade para explorar o c√≥digo, reportar problemas ou sugerir melhorias.
Esperamos que esta atualiza√ß√£o torne a experi√™ncia do usu√°rio mais eficiente e agrad√°vel. Para mais detalhes, consulte a documenta√ß√£o do projeto ou entre em contato.
